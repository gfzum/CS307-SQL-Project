# Report of Project2

*12011411 吴笑丰	12011412 杨鹭鸣	12011216 刘锦润*



## **Content**

- 0.小组成员分工与贡献
- 1.数据库介绍

- 2.各个接口的实现与介绍

- 3.遇到的困难与解决方法

- 4.可进行的优化

- 5.总结与反思



## 0 小组成员分工与贡献

| 姓名   | 学号     | 完成的任务                       | 贡献比 |
| ------ | -------- | -------------------------------- | ------ |
| 吴笑丰 | 12011411 | 实现部分接口+建立git仓库         | 33%    |
| 杨鹭鸣 | 12011412 | 实现部分接口+建立数据库+效率优化 | 34%    |
| 刘锦润 | 12011216 | 实现部分接口+制作报告与ppt       | 33%    |



## 1 数据库介绍

### 1.0 Diagram

![image-20211229025838256](C:\Users\JR\AppData\Roaming\Typora\typora-user-images\image-20211229025838256.png)

### 1.1 三大范式

>**1**.**第一范式(确保每列保持原子性)**

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

>**2**.**第二范式(确保表中的每列都和主键相关)**

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。

也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

>**3**.**第三范式(确保每列都和主键列直接相关,而不是间接相关)**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。



在建造数据库的时候，许多数据不能简单直接地存入数据库，因为这样会违反三大范式。

因此，我们发现了不少问题并找到了解决方案，以下：

### （1）自增id

在json文件中，major和department类型的数据是自带id的，但是dto文件中的参数类型说明中并没有提到这类id，因此在传入函数里并没有关于该id的参数。s

因此，在最初版本的数据库中，建库的时major表格以及department表格中的id我们都是当作传入的id来处理的，但事实上要用自增id作为主键，这样表中的每一列都与同行所在的主键自增id相关，符合第二范式和第三范式。

需要补充的是，此外，要使用自增id的还有section_id, semester_id和class_id等表格

### （2）将数组拆分为单个元素存储

起初建立数据库时，我们将week_list以数组的形式存储在classes中。但是这样很明显违反了第一范式，即表格中每一列都应时刻保持着不可分割的原子性。

因此，我们将week_list中的每一个元素都单独取出，以“week_num”存储在新版classes表格中。对于一个含有16个数字的week_list，将会产生16行的classes。

值得一提的是，我们之前理解的day_of_week是一个集合，因为一周可能有多个时间出现一个class。但是这个数据中day_of_week就只有一个可能。

考虑到这样会出现一些一样的class_id，于是我们将classes表的主键改成了class_id和week_num组成的数对。

但是我们发现了插入数据的时候会产生问题，因为对于同一class的不同week_num,它们的class_id此时不应该增加，换句话说，它们应该拥有相同的class_id。于是我们就要将classes对应的数据分成两块插入，第一块插入第一条数据获得一个自增id，后面都把class_id定义成这个自增id，就可以达成目的了。
